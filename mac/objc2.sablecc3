Package net.pornel.objc2;

Helpers

digit = ['0' .. '9'];
nonzero_digit = ['1' .. '9'];
octal_digit = ['0' .. '7'];
hex_digit = digit | ['a' .. 'f'] | ['A' .. 'F'];
hex_quad = hex_digit hex_digit hex_digit hex_digit;

nondigit = ['a' .. 'z'] | ['A' ..'Z'] | '_';
universal_character_name = ('\' 'u' hex_quad) | ('\' 'U' hex_quad hex_quad);

ident_nondigit = nondigit | universal_character_name ; // "may include other implementation-defined characters"

unsigned_suffix = 'u' | 'U';
long_suffix = ('l' | 'L') | ('LL' | 'll');
integer_suffix = (unsigned_suffix long_suffix?) | (long_suffix unsigned_suffix?);

decimal_constant = nonzero_digit digit*;
octal_constant = '0' | octal_digit;

hex_prefix = '0' ('x' | 'X');
hex_constant = hex_prefix hex_digit+;
integer_constant
    = (decimal_constant integer_suffix?)
    | (octal_constant integer_suffix?)
    | (hex_constant integer_suffix?)
    ;

simple_escape_sequence = '\' (''' | '"' | '?' | '\' | 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v');
octal_escape_sequence = '\' octal_digit (octal_digit octal_digit?)?;
hex_escape_sequence = '\' 'x' hex_digit+;
escape_sequence = simple_escape_sequence | octal_escape_sequence | hex_escape_sequence;

any_char = [0 .. 255];
nl = 10;
cr = 13;
tab = 9;
c_char = [[[any_char - '''] - '\'] - nl] | escape_sequence;
character_constant = 'L'? ''' c_char+ ''';

fractional_constant = (digit* '.' digit+) | (digit+ '.');
hex_fractional_constant = (hex_digit* '.' hex_digit+) | (hex_digit+ '.');

exponent_part = ('e' | 'E') ('+' | '-')? digit+;
binary_exponent_part = ('p' | 'P') ('+' | '-')? digit+;

floating_suffix = ('f' | 'l' | 'F' | 'L');

decimal_floating_constant
    = (fractional_constant exponent_part? floating_suffix?)
    | (digit+ exponent_part floating_suffix?)
    ;

hex_floating_constant = hex_prefix (hex_digit+ | hex_fractional_constant) binary_exponent_part floating_suffix?;

floating_constant = decimal_floating_constant | hex_floating_constant;

s_char = [[[any_char - '"'] - '\'] - nl] | escape_sequence;
string_literal = ('L' | '@') '"' s_char* '"';

h_char = [[any_char - '>'] - nl];
q_char = [[any_char - '"'] - nl];

pp_string = '"' q_char+ '"';

pp_hash = '#' (tab|cr|' ')*;

States
    c, pp; // C and preprocessor

Tokens

// PP

comment = '/*' ([any_char  - '*'] | '*' [any_char - '/'])* '*/';
bcpl_comment = '//' [any_char - nl]*;
line_continuation = '\' nl;

{c,pp->c} newline = cr? nl;
whitespace = (tab|cr|' ')+;

{pp} header_name = ('<' h_char+ '>') | pp_string;

{c->pp} pp_if      = pp_hash 'if';
{c->pp} pp_ifdef   = pp_hash 'ifdef';
{c->pp} pp_ifndef  = pp_hash 'ifndef';
{c->pp} pp_elif    = pp_hash 'elif';
{c->pp} pp_else    = pp_hash 'else';
{c->pp} pp_endif   = pp_hash 'endif';
{c->pp} pp_include = pp_hash 'include';
{c->pp} pp_import  = pp_hash 'import';
{c->pp} pp_define  = pp_hash 'define';
{c->pp} pp_undef   = pp_hash 'undef';
{c->pp} pp_line    = (pp_hash 'line') | (pp_hash ' ' digit+ ' ' pp_string);
{c->pp} pp_error   = pp_hash 'error';
{c->pp} pp_warning = pp_hash 'warning';
{c->pp} pp_pragma  = pp_hash 'pragma';

{pp} pp_whatever = [any_char - nl]+;

// C

{c} plus_plus = '++';
{c} pluseq = '+=';
{c} plus = '+';
{c} minus_minus = '--';
{c} minuseq = '-=';
{c} minusgt = '->';
{c} minus = '-';

{c} stareq = '*=';
{c} star = '*';
{c} slasheq = '/=';
{c} slash = '/';
{c} careteq = '^=';
{c} caret = '^';

{c} gtgteq = '>>=';
{c} gtgt = '>>';
{c} ltlteq = '<<=';
{c} ltlt = '<<';

{c} gte = '>=';
{c} lte = '<=';

{c} gt = '>';
{c} lt = '<';

{c} eqeqeq = '===';
{c} eqeq = '==';
{c} eq = '=';
{c} neqeq = '!==';
{c} neq = '!=';

{c} excl = '!';
{c} tilde = '~';

{c} ampampeq = '&&=';
{c} ampamp = '&&';
{c} ampeq = '&=';
{c} amp = '&';
{c} barbareq = '||=';
{c} barbar = '||';
{c} bareq = '|=';
{c} bar = '|';

{c} percenteq = '%=';
{c} percent = '%';

{c} ellipsis = '...';
{c} dotdot = '..';
{c} dot = '.';

{c} left_paren = '(';
{c} right_paren = ')';
{c} left_square = '[';
{c} right_square = ']';
{c} left_brace = '{';
{c} right_brace = '}';

{c} question = '?';
{c} colon = ':';
{c} semicolon = ';';
{c} comma = ',';

{c} constant = integer_constant | floating_constant | character_constant;
{c} string_literal = ('L' | '@') '"' s_char* '"';

{c} if_keyword = 'if';
{c} else_keyword = 'else';

{c} case_keyword = 'case';
{c} default_keyword = 'default';

{c} var_keyword = 'var';
{c} return_keyword = 'return';
{c} for_keyword = 'for';
{c} in_keyword = 'in';
{c} break_keyword = 'break';
{c} continue_keyword = 'continue';
{c} struct_keyword = 'struct';
{c} union_keyword = 'union';
{c} enum_keyword = 'enum';
{c} sizeof_keyword = 'sizeof';


{c} protocol_qualifier_except_in = 'out' | 'inout' | 'bycopy' | 'byref' | 'oneway'; // 'in' must be separate token
{c} type_qualifier =  'const' | 'volatile' | 'restrict' | '__strong' | '__weak'; // usually contains protocol_qualifier, but that causes ambiguity in for..in

{c} while_keyword = 'while';
{c} do_keyword = 'do';
{c} switch_keyword = 'switch';

{c} type_specifier_keywords = 'void' | 'char' | 'short' | 'int' | 'long' | 'float' | 'double' | 'signed' | 'unsigned' | '_Bool' | '_Complex' | '_Imaginary';

{c} storage_class_specifier = 'auto' | 'register' | 'static' | 'extern';

{c} function_specifier = 'inline';

{c} goto_keyword = 'goto';

{c} typedefed_ident = '__use_lexer_hack_to_add_all_typedefs__' | 'BOOL' | 'IMP' | 'SEL' | 'Class' | 'id';

{c} typedef_keyword = 'typedef';

{c} at_implementation = '@implementation';
{c} at_interface = '@interface';
{c} at_protocol = '@protocol';
{c} at_encode = '@encode';
{c} at_synchronized = '@synchronized';
{c} at_selector = '@selector';
{c} at_end = '@end';
{c} at_defs = '@defs';
{c} at_class = '@class';

{c} at_try = '@try';
{c} at_throw = '@throw';
{c} at_catch = '@catch';
{c} at_finally = '@finally';

{c} at_private    = '@private';
{c} at_package    = '@package';
{c} at_public     = '@public';
{c} at_protected  = '@protected';

{c} at_property = '@property';
{c} at_synthesize = '@synthesize';
{c} at_dynamic = '@dynamic';

{c} at_optional = '@optional';
{c} at_required = '@required';

{c} ident = ident_nondigit ( ident_nondigit | digit )*;


Ignored Tokens

newline, whitespace, comment, bcpl_comment, line_continuation,

pp_if, pp_ifdef, pp_ifndef, pp_elif, pp_else, pp_endif, pp_include, pp_import, pp_define, pp_undef, pp_line, pp_error, pp_warning, pp_pragma, pp_whatever, header_name;


Productions

translation_unit
    = external_declaration*
    ;

primary_expression {->expr}
    = {ident} ident
        {-> New expr.var(ident)}
    | {constant} constant
        {-> New expr.constant(constant)}
    | {string} string
        {-> New expr.string(string)}
    | {expression} left_paren expression right_paren
        {-> expression.expr}
    | {message_expression} message_expression
        {-> message_expression.expr}
    | {selector_expression} selector_expression
        {-> selector_expression.expr}
    | {protocol_expression} protocol_expression
        {-> protocol_expression.expr}
    | {encode_expression} encode_expression
        {-> encode_expression.expr}
    ;

string
    = string_literal+
    ;

message_expression {-> expr}
    = left_square receiver message_selector right_square
        {-> New expr.message(receiver.expr, [message_selector.message_argument])}
    ;

receiver {->expr}
    = expression // catches 'self' and 'super' as ident
        {-> expression.expr}
    | {class_name} typedefed_ident // requires lexer hack
        {-> New expr.type_object(typedefed_ident)}
    ;

message_selector {->message_argument*}
    = {unary} ident
        {-> [New message_argument(ident,Null)]}
    | keyword_argument+
        {-> [keyword_argument.message_argument]}
    ;

keyword_argument {->message_argument}
    = {ident} ident colon expression
        {-> New message_argument(ident, expression.expr)}
    | colon expression
        {-> New message_argument(Null, expression.expr)}
    ;

postfix_expression {->expr}
    = {primary_expression} primary_expression
        {-> primary_expression.expr}
    | {array} postfix_expression left_square expression right_square
        {-> New expr.array(postfix_expression.expr, expression.expr)}
    | {call} postfix_expression left_paren argument_expression_list? right_paren
        {-> New expr.call(postfix_expression.expr,[argument_expression_list.expr])}
    | {member} postfix_expression dot ident
        {-> New expr.member(postfix_expression.expr, ident)}
    | {member_ptr} postfix_expression minusgt ident
        {-> New expr.member_ptr(postfix_expression.expr, ident)}
    | {inc} postfix_expression plus_plus
        {-> New expr.postinc(postfix_expression.expr)}
    | {dec} postfix_expression minus_minus
        {-> New expr.postdec(postfix_expression.expr)}
    | {c99} left_paren type_name right_paren left_brace initializer_list comma? right_brace
        {-> New expr.literal(type_name.type, [initializer_list.initializer])}
    ;

argument_expression_list {-> expr*}
    = {assignment_expression} assignment_expression
        {->[assignment_expression.expr]}
    | argument_expression_list comma assignment_expression
        {->[argument_expression_list.expr, assignment_expression.expr]}
    ;

unary_expression {->expr}
    = {postfix_expression} postfix_expression
        {-> postfix_expression.expr}
    | {inc} plus_plus unary_expression
        {-> New expr.preinc(unary_expression.expr)}
    | {dec} minus_minus unary_expression
        {-> New expr.predec(unary_expression.expr)}
    | {amp} amp cast_expression
        {-> New expr.addressof(cast_expression.expr)}
    | {star} star cast_expression
        {-> New expr.dereference(cast_expression.expr)}
    | {plus} plus cast_expression
        {-> cast_expression.expr}
    | {minus} minus cast_expression
        {-> New expr.negate(cast_expression.expr)}
    | {tilde} tilde cast_expression
        {-> New expr.bitnegate(cast_expression.expr)}
    | {excl} excl cast_expression
        {-> New expr.not(cast_expression.expr)}
    | {sizeof} sizeof_keyword unary_expression
        {-> New expr.sizeof(unary_expression.expr)}
    | {sizeof_type} sizeof_keyword left_paren type_name right_paren
        {-> New expr.sizeof_type(type_name.type)}
    ;

cast_expression {->expr}
    = {unary_expression} unary_expression
        {->unary_expression.expr}
    | left_paren type_name right_paren cast_expression
        {->New expr.cast(cast_expression.expr, type_name.type)}
    ;

multiplicative_expression {->expr}
    = {cast_expression} cast_expression
        {-> cast_expression.expr}
    | {star} multiplicative_expression star cast_expression
        {-> New expr.mul(multiplicative_expression.expr, cast_expression.expr)}
    | {slash} multiplicative_expression slash cast_expression
        {-> New expr.div(multiplicative_expression.expr, cast_expression.expr)}
    | {percent} multiplicative_expression percent cast_expression
        {-> New expr.mod(multiplicative_expression.expr, cast_expression.expr)}
    ;

additive_expression {->expr}
    = {multiplicative_expression} multiplicative_expression
        {->multiplicative_expression.expr}
    | {plus} additive_expression plus multiplicative_expression
        {->New expr.add(additive_expression.expr, multiplicative_expression.expr)}
    | {minus} additive_expression minus multiplicative_expression
        {->New expr.sub(additive_expression.expr, multiplicative_expression.expr)}
    ;

shift_expression {->expr}
    = {additive_expression} additive_expression
        {->additive_expression.expr}
    | {ltlt} shift_expression ltlt additive_expression
        {-> New expr.shiftleft(shift_expression.expr, additive_expression.expr)}
    | {gtgt} shift_expression gtgt additive_expression
        {-> New expr.shiftright(shift_expression.expr, additive_expression.expr)}
    ;

relational_expression {->expr}
    = {shift_expression} shift_expression
        {->shift_expression.expr}
    | {lt} relational_expression lt shift_expression
        {-> New expr.lt(relational_expression.expr, shift_expression.expr)}
    | {gt} relational_expression gt shift_expression
        {-> New expr.gt(relational_expression.expr, shift_expression.expr)}
    | {lteq} relational_expression lte shift_expression
        {-> New expr.lte(relational_expression.expr, shift_expression.expr)}
    | {gteq} relational_expression gte shift_expression
        {-> New expr.gte(relational_expression.expr, shift_expression.expr)}
    ;

equality_expression {->expr}
    = {relational_expression} relational_expression
        {-> relational_expression.expr}
    | {eqeq} equality_expression eqeq relational_expression
        {-> New expr.equal(equality_expression.expr, relational_expression.expr)}
    | {neq} equality_expression neq relational_expression
        {-> New expr.notequal(equality_expression.expr, relational_expression.expr)}
    ;

and_expression {->expr}
    = {equality_expression} equality_expression
        {-> equality_expression.expr}
    | and_expression amp equality_expression
        {-> New expr.bitand(and_expression.expr, equality_expression.expr)}
    ;

exclusive_or_expression {->expr}
    = {and_expression} and_expression
        {-> and_expression.expr}
    | exclusive_or_expression caret and_expression
        {-> New expr.bitxor(exclusive_or_expression.expr, and_expression.expr)}
    ;

inclusive_or_expression {->expr}
    = {exclusive_or_expression} exclusive_or_expression
        {->exclusive_or_expression.expr}
    | inclusive_or_expression bar exclusive_or_expression
        {-> New expr.bitor(inclusive_or_expression.expr, exclusive_or_expression.expr)}
    ;

logical_and_expression {->expr}
    = {inclusive_or_expression} inclusive_or_expression
        {->inclusive_or_expression.expr}
    | logical_and_expression ampamp inclusive_or_expression
        {-> New expr.and(logical_and_expression.expr, inclusive_or_expression.expr)}
    ;

logical_or_expression {->expr}
    = {logical_and_expression} logical_and_expression
        {->logical_and_expression.expr}
    | logical_or_expression barbar logical_and_expression
        {-> New expr.or(logical_or_expression.expr, logical_and_expression.expr)}
    ;

conditional_expression {->expr}
    = {logical_or_expression} logical_or_expression
        {-> logical_or_expression.expr}
    | logical_or_expression question expression colon conditional_expression
        {-> New expr.ternary(logical_or_expression.expr,expression.expr,conditional_expression.expr)}
    ;

assignment_expression {->expr}
    = {conditional_expression} conditional_expression
        {-> conditional_expression.expr}
    | {eq} unary_expression eq assignment_expression
        {-> New expr.assign(unary_expression.expr, assignment_expression.expr)}
    | {stareq} unary_expression stareq assignment_expression
        {-> New expr.mulassign(unary_expression.expr, assignment_expression.expr)}
    | {slasheq} unary_expression slasheq assignment_expression
        {-> New expr.divassign(unary_expression.expr, assignment_expression.expr)}
    | {percenteq} unary_expression percenteq assignment_expression
        {-> New expr.modassign(unary_expression.expr, assignment_expression.expr)}
    | {pluseq} unary_expression pluseq assignment_expression
        {-> New expr.addassign(unary_expression.expr, assignment_expression.expr)}
    | {minuseq} unary_expression minuseq assignment_expression
        {-> New expr.subassign(unary_expression.expr, assignment_expression.expr)}
    | {ltlteq} unary_expression ltlteq assignment_expression
        {-> New expr.shlassign(unary_expression.expr, assignment_expression.expr)}
    | {gtgteq} unary_expression gtgteq assignment_expression
        {-> New expr.shrassign(unary_expression.expr, assignment_expression.expr)}
    | {ampeq} unary_expression ampeq assignment_expression
        {-> New expr.bitandassign(unary_expression.expr, assignment_expression.expr)}
    | {careteq} unary_expression careteq assignment_expression
        {-> New expr.bitxorassign(unary_expression.expr, assignment_expression.expr)}
    | {bareq} unary_expression bareq assignment_expression
        {-> New expr.bitorassign(unary_expression.expr, assignment_expression.expr)}
    ;

expression {-> expr}
    = {assignment_expression} assignment_expression
        {->assignment_expression.expr}
    | expression comma assignment_expression
        {-> New expr.comma(expression.expr, assignment_expression.expr)}
    ;

constant_expression {->expr}
    = conditional_expression
        {->conditional_expression.expr}
    ;


declaration
    = {var} declaration_specifier+ init_declarator_list? semicolon
        {-> New declaration.declaration([declaration_specifier.declaration_specifier], [init_declarator_list.declarator])}
    | {typedef} typedef_keyword declaration_specifier+ declarator semicolon
        {-> New declaration.typedef([declaration_specifier.declaration_specifier], declarator.declarator)}
    ;

declaration_specifier {-> declaration_specifier}
    = {storage_class} storage_class_specifier  // inline, auto, register
        {-> New declaration_specifier.storage_class(storage_class_specifier)}
    | {type_specifier} type_specifier // int, struct, union, id
        {-> New declaration_specifier.type_specifier(type_specifier)}
    | {type_qualifier} type_qualifier // const/volatile
        {-> New declaration_specifier.type_qualifier(type_qualifier)}
    | {c99} function_specifier
        {-> New declaration_specifier.function_specifier(function_specifier)}
    ;

init_declarator_list {-> declarator*}
    = {init_declarator} init_declarator
        {-> [init_declarator.declarator]}
    | init_declarator_list comma init_declarator
        {-> [init_declarator_list.declarator, init_declarator.declarator]}
    ;

init_declarator {->declarator}
    = {declarator} declarator
        {->declarator.declarator}
    | declarator eq initializer
        {->New declarator.init_declarator(declarator.declarator, initializer.initializer)}
    ;

protocol_qualifier
    = {proxy} protocol_qualifier_except_in
    | in_keyword
    ;

type_specifier {->type_specifier}
    = {type_specifier_keywords} type_specifier_keywords
        {-> New type_specifier.base_type(type_specifier_keywords)}
    | {struct} struct_specifier
        {-> struct_specifier.type_specifier}
    | {union} union_specifier
        {-> union_specifier.type_specifier}
    | {enum} enum_specifier
        {-> enum_specifier.type_specifier}
    | {typedef_name} typedefed_ident protocol_reference_list? // requires lexer hack
                                                              // (id|type)  [ protocol_reference_list ]
        {-> New type_specifier.typedefed(typedefed_ident, [protocol_reference_list.ident])}
    ;

type_specifier_with_unknown_type {->type_specifier}
    = type_specifier
        {->type_specifier.type_specifier}
    | {ambiguous} ident protocol_reference_list? // ident represents typedefed_ident, hack not needed here
        {-> New type_specifier.type_ident(ident, [protocol_reference_list.ident])}
    ;

struct_specifier {->type_specifier}
    = {std}  struct_keyword ident? left_brace struct_declaration* right_brace
        {-> New type_specifier.struct(ident)}
    | {defs} struct_keyword ident? left_brace at_defs left_paren class_name right_paren right_brace
        {-> New type_specifier.struct(ident)}
    | {ident} struct_keyword ident
        {-> New type_specifier.struct(ident)}
    ;

union_specifier {->type_specifier}
    = {std}  union_keyword ident? left_brace struct_declaration* right_brace
        {-> New type_specifier.union(ident)}
    | {defs} union_keyword ident? left_brace at_defs left_paren class_name right_paren right_brace
        {-> New type_specifier.union(ident)}
    | {ident} union_keyword ident
        {-> New type_specifier.union(ident)}
    ;

struct_declaration
    = specifier_qualifier+ struct_declarator_list semicolon
    ;

specifier_qualifier
    = {type_specifier} type_specifier // int, struct, union, id
    | {type_qualifier} type_qualifier // const/volatile
    | {protocol_qualifier} protocol_qualifier // inout, oneway
    ;

specifier_qualifier_with_unknown_type
    = {type_specifier} type_specifier_with_unknown_type
    | {type_qualifier} type_qualifier
    | {protocol_qualifier} protocol_qualifier
    ;

struct_declarator_list
    = {struct_declarator} struct_declarator
    | struct_declarator_list comma struct_declarator
    ;

struct_declarator
    = declarator
    | {bitfield} declarator? colon constant_expression
    ;

enum_specifier {->type_specifier}
    = enum_keyword ident? left_brace enumerator_list comma? right_brace
        {-> New type_specifier.enum(ident,[enumerator_list.enumerator])}
    | {declaration} enum_keyword ident
        {-> New type_specifier.enum(ident,[])}
    ;

enumerator_list {->enumerator+}
    = {enumerator} enumerator
        {->[enumerator.enumerator]}
    | enumerator_list comma enumerator
        {->[enumerator_list.enumerator, enumerator.enumerator]}
    ;

enumerator {->enumerator}
    = {ident} ident
        {-> New enumerator(ident,Null)}
    | ident eq constant_expression
        {-> New enumerator(ident, constant_expression.expr)}
    ;

declarator {-> declarator}
    = {pointer} pointer declarator
        {-> New declarator.pointer(declarator.declarator,[pointer.type_qualifier])}
    | direct_declarator
        {-> direct_declarator.declarator}
    ;
direct_declarator {->declarator}
    = {ident} ident
        {-> New declarator.name(ident)}
    | {declarator} left_paren declarator right_paren
        {-> declarator.declarator}
    | {array} direct_declarator left_square type_qualifier* assignment_expression? right_square
        {-> New declarator.array(direct_declarator.declarator, assignment_expression.expr)}
    | {parameter_type_list} direct_declarator left_paren parameter_type_list right_paren
        {-> New declarator.function(direct_declarator.declarator)}
    | {identifier_list} direct_declarator left_paren identifier_list? right_paren
        {-> New declarator.function(direct_declarator.declarator)}
        /* C99
        direct-declarator [ type-qualifier-listopt
        direct-declarator [ static  type-qualifier-listopt  assignment-expression ]
        direct-declarator [type-qualifier-list static assignment-expression]
        direct-declarator [type-qualifier-listopt *]
        */
    ;

// changed from pointer list to singular pointer
pointer {->type_qualifier*}
    = star type_qualifier*
        {-> [type_qualifier]}
    ;

parameter_type_list
    = {parameter_list} parameter_list
    | parameter_list comma ellipsis
    ;

parameter_list
    = {parameter_declaration} parameter_declaration
    | parameter_list comma parameter_declaration
    ;

parameter_declaration
    = {declarator} declaration_specifier+ declarator
    | declaration_specifier+ abstract_declarator?
    ;

identifier_list
    = {ident} ident
    | identifier_list comma ident
    ;

type_name {->type}
    = specifier_qualifier+ abstract_declarator?
        {-> New type()}
    ;

type_name_with_unknown_type {->type}
    = specifier_qualifier_with_unknown_type+ abstract_declarator?
        {-> New type()}
    ;

abstract_declarator {->declarator}
    = {pointer} pointer abstract_declarator?
        {-> New declarator.pointer(abstract_declarator.declarator, [pointer.type_qualifier])}
    | direct_abstract_declarator
        {->direct_abstract_declarator.declarator}
    ;

direct_abstract_declarator {->declarator}
    = {abstract_declarator} left_paren abstract_declarator right_paren
        {-> abstract_declarator.declarator}
    | {array} direct_abstract_declarator? left_square assignment_expression? right_square
        {-> New declarator.array(direct_abstract_declarator.declarator, assignment_expression.expr)}
    | {parameter_type_list} direct_abstract_declarator? left_paren parameter_type_list? right_paren
        {-> New declarator.function(Null)}
    | {c99} direct_abstract_declarator? left_square star right_square
        {-> New declarator.array_vla(direct_abstract_declarator.declarator)}
    ;

initializer {-> initializer}
    = assignment_expression
        {-> New initializer.expression(assignment_expression.expr)}
    | {aggregate} left_brace initializer_list comma? right_brace
        {-> New initializer.aggregate([initializer_list.initializer])}
    ;

initializer_list {->initializer*}
    = {initializer} initializer
        {->[initializer.initializer]}
    | {designation} designation initializer
        {-> [New initializer.designated(initializer.initializer)]}
    | {list} initializer_list comma initializer
        {-> [initializer_list.initializer, initializer.initializer]}
    | {deslist} initializer_list comma designation initializer
        {-> [initializer_list.initializer, New initializer.designated(initializer.initializer)]}
    ;

designation
    = designator+ eq
    ;

designator
    = left_square constant_expression right_square
    | {dot} dot ident
    ;

statement
    = statement_no_trailing_substatement
        {-> statement_no_trailing_substatement.statement}
    | {selection_statement} selection_statement
        {-> selection_statement.statement}
    | {labeled_statement} labeled_statement_start statement
        {-> New statement.labeled(labeled_statement_start.ident, statement.statement)}
    | {case_statement} case_statement_start statement
        {-> New statement.case(case_statement_start.expr, statement.statement)}
    | {for_statement} for_statement_start statement
        {-> New statement.for(for_statement_start.init, for_statement_start.condition, for_statement_start.iteration, statement.statement)}
    | {for_in_statement} for_in_statement_start statement
        {-> New statement.for_in(for_in_statement_start.expr, statement.statement)}
    | {while_statement} while_statement_start statement
        {-> New statement.while(while_statement_start.expr, statement.statement)}
    | {synchronized_statement} synchronized_statement_start statement
        {-> New statement.synchronized(synchronized_statement_start.expr, statement.statement)}
    ;

statement_no_short_if {-> statement}
    = statement_no_trailing_substatement
        {->statement_no_trailing_substatement.statement}
    | {selection_statement} selection_statement_no_short_if
        {-> selection_statement_no_short_if.statement}
    | {labeled_statement} labeled_statement_start statement_no_short_if
        {-> New statement.labeled(labeled_statement_start.ident, statement_no_short_if.statement)}
    | {case_statement} case_statement_start statement_no_short_if
        {-> New statement.case(case_statement_start.expr, statement_no_short_if.statement)}
    | {for_statement} for_statement_start statement_no_short_if
        {-> New statement.for(for_statement_start.init, for_statement_start.condition, for_statement_start.iteration, statement_no_short_if.statement)}
    | {for_in_statement} for_in_statement_start statement_no_short_if
        {-> New statement.for_in(for_in_statement_start.expr, statement_no_short_if.statement)}
    | {while_statement} while_statement_start statement_no_short_if
        {-> New statement.while(while_statement_start.expr, statement_no_short_if.statement)}
    | {synchronized_statement} synchronized_statement_start statement_no_short_if
        {-> New statement.synchronized(synchronized_statement_start.expr, statement_no_short_if.statement)}
    ;

statement_no_trailing_substatement {->statement}
    = {jump_statement} jump_statement
            {-> jump_statement.statement}
    | {compound_statement} compound_statement
            {-> compound_statement.statement}
    | {expression_statement} expression_statement
            {-> expression_statement.statement}
    | {do} do_keyword statement while_keyword left_paren expression right_paren semicolon
            {-> New statement.do(expression.expr, statement.statement)}
    | {try_block} try_block
            {-> try_block.statement}
    ;

labeled_statement_start {->ident}
    = ident colon {->ident}
    ;

case_statement_start {->expr?}
    = {case} case_keyword constant_expression colon {->constant_expression.expr}
    | {default} default_keyword colon {->Null}
    ;

compound_statement {-> statement}
    = left_brace block_item* right_brace
            {-> New statement.block([block_item.statement])}
    ;

block_item {-> statement}
    = {declaration} declaration
            {-> New statement.declaration(declaration.declaration)}
    | statement
            {-> statement}
    ;

expression_statement {->statement}
    = expression? semicolon {-> New statement.expression(expression.expr)}
    ;

selection_statement {->statement}
    = {if} if_keyword left_paren expression right_paren statement
        {-> New statement.if(expression.expr, statement.statement, Null)}
    | {ifelse} if_keyword left_paren expression right_paren [then]:statement_no_short_if else_keyword [else]:statement
        {-> New statement.if(expression.expr, then.statement, else.statement)}
    | {switch} switch_keyword left_paren expression right_paren statement
        {-> New statement.switch(expression.expr, statement.statement)}
    ;

selection_statement_no_short_if {->statement}
    = {ifelse} if_keyword left_paren expression right_paren [then]:statement_no_short_if else_keyword [else]:statement_no_short_if
        {-> New statement.if(expression.expr, then.statement, else.statement)}
    | {switch} switch_keyword left_paren expression right_paren statement_no_short_if
        {-> New statement.switch(expression.expr, statement_no_short_if.statement)}
    ;

while_statement_start {->expr}
    = while_keyword left_paren expression right_paren {->expression.expr}
    ;

for_in_iteration_variable
    = {new} parameter_declaration // I'm not sure if it's correct
    | ident
    ;

for_statement_start {->[init]:expr? [condition]:expr? [iteration]:expr?}
    = for_keyword left_paren [expr1]:expression? semicolon [expr2]:expression? [s2]:semicolon [expr3]:expression? right_paren
        {-> expr1.expr expr2.expr expr3.expr}
    ;

for99_statement_start
    = for_keyword left_paren declaration [expr1]:expression? semicolon [expr2]:expression? right_paren
    ;

for_in_statement_start {->expr}
    = for_keyword left_paren for_in_iteration_variable in_keyword expression right_paren
        {->expression.expr} // FIXME: iter var missing
    ;

synchronized_statement_start {->expr}
    = at_synchronized left_paren expression right_paren {->expression.expr}
    ;

jump_statement {->statement}
    = goto_keyword ident semicolon
        {-> New statement.goto(ident)}
    | {continue_keyword} continue_keyword semicolon
        {-> New statement.continue()}
    | {break_keyword} break_keyword semicolon
        {-> New statement.break()}
    | {return_expr} return_keyword expression? semicolon
        {-> New statement.return()}
    ;

try_block {->statement}
    // allows statement, but that causes another dangling else problem
    = {catch} at_try compound_statement catch_clause+ finally_statement?
        {-> New statement.try(compound_statement.statement, [catch_clause.catch_clause], finally_statement.statement)}
    | {finally} at_try compound_statement finally_statement
        {-> New statement.try(compound_statement.statement, [], finally_statement.statement)}
    ;

catch_clause {->catch_clause}
    // allows statement, but that causes another dangling else problem
    = at_catch left_paren declarator right_paren compound_statement
        {-> New catch_clause(Null, compound_statement.statement)} // FIXME: declarator
    | {default_catch_clause} at_catch left_paren ellipsis right_paren compound_statement
        {-> New catch_clause(Null, compound_statement.statement)}
    ;

finally_statement {->statement}
    // allows statement, but try_block needs to be refactored
    = at_finally compound_statement
        {->compound_statement.statement}
    ;

throw_statement {->statement}
    = at_throw left_paren ident? right_paren
        {-> New statement.throw(ident)}
    ;

external_declaration
    = {function_definition} function_definition
    | {declaration} declaration
            {-> New external_declaration.declaration(declaration.declaration)}
    | {class_interface} class_interface
            {-> New external_declaration.class_interface(class_interface)}
    | {class_implementation} class_implementation
            {-> New external_declaration.class_implementation(class_implementation.class_implementation)}
    | {category_interface} category_interface
            {-> New external_declaration.class_interface(category_interface.class_interface)}
    | {category_implementation} category_implementation
            {-> New external_declaration.class_implementation(category_implementation.class_implementation)}
    | {protocol_declaration} protocol_declaration
    | {class_declaration_list} class_declaration_list
            {-> New external_declaration.declaration(class_declaration_list.declaration)}
    ;

function_definition
    = declaration_specifier+ declarator declaration* compound_statement
            {->New function_definition(compound_statement.statement)}
    ;

class_interface
    = at_interface class_name [superclass]:colon_superclass_name? protocol_reference_list? instance_variables? [declarations]:interface_declaration* at_end
        {-> New class_interface(class_name.ident, superclass.ident, [declarations.interface_declaration])}
    ;

class_implementation
    = at_implementation class_name
      [superclass]:colon_superclass_name?
      instance_variables?
      [definitions]:implementation_definition*
      at_end
        {-> New class_implementation(class_name.ident, superclass.ident, [definitions.implementation_definition])}
    ;

category_interface {-> class_interface}
    = at_interface class_name left_paren category_name? right_paren protocol_reference_list? [declarations]:interface_declaration* at_end
        {-> New class_interface(class_name.ident, Null, [declarations.interface_declaration])}
    ;

category_implementation {-> class_implementation}
    = at_implementation class_name left_paren category_name right_paren [definitions]:implementation_definition* at_end
        {->New class_implementation(class_name.ident, Null, [definitions.implementation_definition])}
    ;

protocol_declaration {-> protocol_declaration}
    = at_protocol protocol_name protocol_reference_list? protocol_interface_declaration at_end
        {->New protocol_declaration()}
    ;

class_declaration_list {-> declaration}
    = at_class class_list
        {-> New declaration.classes([class_list.ident])}
    ;

class_list {->ident+}
    = {class_name} class_name {-> [class_name.ident]}
    | class_list comma class_name {-> [class_list.ident, class_name.ident]}
    ;

protocol_reference_list {->ident+}
    = lt protocol_list gt
        {-> [protocol_list.ident]}
    ;

protocol_list {->ident+}
    = {protocol_name} protocol_name
        {-> [protocol_name.ident]}
    | protocol_list comma protocol_name
        {-> [protocol_list.ident, protocol_name.ident]}
    ;

class_name {->ident}
    = ident {->ident}
    ;

superclass_name {->ident}
    = ident {->ident}
    ;

colon_superclass_name {->ident}
    = colon superclass_name
        {->superclass_name.ident}
    ;

category_name
    = ident
    ;

protocol_name {->ident}
    = ident {->ident}
    ;

instance_variables
    = left_brace instance_variable_declaration right_brace
    ;

instance_variable_declaration
    = {visibility_specification} visibility_specification
    | {struct_declaration} struct_declaration+ instance_variables
    | {list1} instance_variable_declaration visibility_specification
    | {list2} instance_variable_declaration struct_declaration+ instance_variables
    ;

visibility_specification
    = {at_private} at_private
    | {at_protected} at_protected
    | {at_package} at_package
    | {at_public} at_public
    ;

protocol_interface_declaration
    = {default_required} interface_declaration* qualified_protocol_interface_declaration*
    ;

qualified_protocol_interface_declaration
    = {opt} at_optional interface_declaration*
    | {req} at_required interface_declaration*
    ;

interface_declaration
    = {declaration} declaration
        {-> New interface_declaration()}
    | {property} property_declaration
        {-> New interface_declaration()}
    | {method_declaration} method_declaration
        {-> New interface_declaration()}
    ;

property_declaration
    = at_property property_attributes_declaration? struct_declaration
    ;

property_attributes_declaration
    = left_paren property_attributes_list right_paren
    ;

property_attributes_list
    = property_attribute
    | {list} property_attributes_list comma property_attribute
    ;

property_attribute
    = ident // nonatomic, readwrite, readonly, retain, assign, copy
    | {getter} ident eq [getter_or_ivar]:ident //  getter ivar
    | {setter} ident eq [prop]:ident colon // setter
    ;

method_declaration
    = {class_method_declaration} class_method_declaration
    | {instance_method_declaration} instance_method_declaration
    ;

class_method_declaration
    = plus method_type? method_selector semicolon
    ;

instance_method_declaration
    = minus method_type? method_selector semicolon
    ;

implementation_definition {->implementation_definition}
    = {function_definition} function_definition
        {-> New implementation_definition.function_definition(function_definition)}
    | {declaration} declaration
        {-> New implementation_definition.declaration(declaration.declaration)}
    | {property} property_implementation
        {-> New implementation_definition.property_implementation(property_implementation.property_implementation)}
    | {method_definition} method_definition
        {-> New implementation_definition.method_definition(method_definition)}
    ;

property_implementation {->property_implementation}
    = at_synthesize property_synthesize_list semicolon
        {-> New property_implementation.synthesize([property_synthesize_list.property_name])}
    | {dynamic} at_dynamic property_synthesize_list semicolon
        {-> New property_implementation.dynamic([property_synthesize_list.property_name])}
    ;

property_synthesize_list {-> property_name*}
    = {list} property_synthesize_list comma property_synthesize_item
        {-> [property_synthesize_list.property_name, property_synthesize_item.property_name]}
    | property_synthesize_item
        {->[property_synthesize_item.property_name]}
    ;

property_synthesize_item {-> property_name}
    = ident
        {->New property_name(ident,Null)}
    | {ivar} [prop]:ident eq ident
        {-> New property_name(prop,ident)}
    ;

method_definition
    = {class_method_definition} class_method_definition
        {-> class_method_definition.method_definition}
    | {instance_method_definition} instance_method_definition
        {-> instance_method_definition.method_definition}
    ;

class_method_definition {-> method_definition}
    = plus method_type? method_selector_no_list declaration* semicolon? compound_statement
        {-> New method_definition.class_method_definition(compound_statement.statement)}
    ;

instance_method_definition {-> method_definition}
    = minus method_type? method_selector_no_list declaration* semicolon? compound_statement
        {-> New method_definition.instance_method_definition(compound_statement.statement)}
    ;

method_selector_no_list
    = {unary_selector} unary_selector
    | {keyword_selector} keyword_selector
    | {ellipsis} keyword_selector comma ellipsis
    ;

method_selector
    = {other} method_selector_no_list
    | keyword_selector comma parameter_type_list // this is correct according to objcbook, but causes conflict if followed by declaration*
    ;

unary_selector
    = selector
    ;

keyword_selector
    = keyword_declarator+
    ;

keyword_declarator
    = selector? colon method_type? ident
    ;

selector {->ident}
    = ident {->ident}
    ;

method_type {->type}
    = left_paren type_name_with_unknown_type right_paren
        {-> type_name_with_unknown_type.type}
    ;

selector_expression {->expr}
    = at_selector left_paren selector_name right_paren
        {-> New expr.selector([selector_name.ident])}
    ;

selector_name {->ident*}
    = {unary} selector
        {->[selector.ident]}
    | keyword_name+
        {->[keyword_name.ident]}
    ;

keyword_name {->ident?}
    = selector? colon
        {->selector.ident}
    ;

protocol_expression {->expr}
    = at_protocol left_paren protocol_name right_paren
        {-> New expr.protocol(protocol_name.ident)}
    ;

encode_expression {->expr}
    = at_encode left_paren type_name_with_unknown_type right_paren
        {-> New expr.encode(type_name_with_unknown_type.type)}
    ;


Abstract Syntax Tree

translation_unit = external_declaration*;

external_declaration
        = {function_definition} function_definition
        | {declaration} declaration
        | {class_interface} class_interface
        | {class_implementation} class_implementation
        | {protocol_declaration} protocol_declaration
        ;

function_definition = [body]:statement;

declaration = {classes}     [names]:ident+
            | {declaration} [specifier]:declaration_specifier+ [declarator]:declarator*
            | {typedef}     [specifier]:declaration_specifier+ [declarator]:declarator
            ;

class_interface = [name]:ident [superclass]:ident? [definitions]:interface_declaration*;
class_implementation = [name]:ident [superclass]:ident? [definitions]:implementation_definition*;
protocol_declaration = ;

interface_declaration = ;
implementation_definition = {declaration} declaration
                          | {function_definition} function_definition
                          | {property_implementation} property_implementation
                          | {method_definition} method_definition
                          ;

property_implementation = {dynamic} property_name*
                        | {synthesize} property_name*;

property_name = [name]:ident [ivar]:ident?;

method_definition = {instance_method_definition} [body]:statement
                  | {class_method_definition} [body]:statement
                  ;

statement = {block}       [body]:statement*
          | {if}          [condition]:expr [then]:statement [else]:statement?
          | {for}         [init]:expr? [condition]:expr? [iteration]:expr? [body]:statement
          | {for_in}      [value]:expr [body]:statement
          | {switch}      [value]:expr [body]:statement
          | {continue}
          | {break}
          | {return}
          | {case}        [value]:expr?  [body]:statement // Null = default
          | {goto}        [label]:ident
          | {do}          [condition]:expr [body]:statement
          | {while}       [condition]:expr [body]:statement
          | {declaration} declaration
          | {labeled}     [label]:ident [body]:statement
          | {expression}  [value]:expr?
          | {synchronized} [value]:expr [body]:statement
          | {throw}       [throw]:ident? // Null = rethrow
          | {try}         [body]:statement [catch]:catch_clause* [finally]:statement?
          ;

catch_clause = [declarator]:ident? [body]:statement; // FIXME

expr = {add}    [left]:expr [right]:expr
     | {sub}    [left]:expr [right]:expr
     | {mul}    [left]:expr [right]:expr
     | {div}    [left]:expr [right]:expr
     | {mod}    [left]:expr [right]:expr
     | {negate} [value]:expr                   // -x

     | {shiftleft}    [value]:expr [by]:expr   // x << y
     | {shiftright}   [value]:expr [by]:expr   // x >> y
     | {bitand}       [left]:expr [right]:expr // a & b
     | {bitor}        [left]:expr [right]:expr // a | b
     | {bitxor}       [left]:expr [right]:expr // a ^ b
     | {bitnegate}    [value]:expr             // ~a

     | {assign}       [left]:expr [right]:expr
     | {addassign}    [left]:expr [right]:expr
     | {subassign}    [left]:expr [right]:expr
     | {mulassign}    [left]:expr [right]:expr
     | {divassign}    [left]:expr [right]:expr
     | {modassign}    [left]:expr [right]:expr
     | {shlassign}    [left]:expr [right]:expr
     | {shrassign}    [left]:expr [right]:expr
     | {bitandassign} [left]:expr [right]:expr
     | {bitorassign}  [left]:expr [right]:expr
     | {bitxorassign} [left]:expr [right]:expr
     | {andassign}    [left]:expr [right]:expr  // foo &&= bar → foo = foo && bar → foo = foo ? bar : false
     | {orassign}     [left]:expr [right]:expr  // foo ||= bar → foo = foo || bar → foo = bar ? bar : foo

     | {not}       [value]:expr                    // !x
     | {and}       [left]:expr [right]:expr
     | {or}        [left]:expr [right]:expr
     | {gt}        [left]:expr [right]:expr
     | {gte}       [left]:expr [right]:expr
     | {lt}        [left]:expr [right]:expr
     | {lte}       [left]:expr [right]:expr

     | {equal}     [left]:expr [right]:expr   // ==
     | {notequal}  [left]:expr [right]:expr   // !=
     | {same}      [left]:expr [right]:expr   // ===
     | {notsame}   [left]:expr [right]:expr   // !==

     | {ternary}   [condition]:expr [then]:expr [else]:expr

     | {dereference} [value]:expr            // *x
     | {addressof}   [value]:expr            // &x

     | {preinc}      [value]:expr            // ++x
     | {predec}      [value]:expr            // --x
     | {postinc}     [value]:expr            // x++
     | {postdec}     [value]:expr            // x--

     | {message}     [value]:expr [arguments]:message_argument*  // foo bar:x baz:y
     | {call}        [value]:expr [arguments]:expr*         // foo()

     | {array}       [value]:expr [index]:expr              // foo[bar]
     | {member}      [value]:expr [name]:ident              // foo.bar
     | {member_ptr}  [value]:expr [name]:ident

     | {var}         [name]:ident                           // foo
     | {type_object} [name]:typedefed_ident                 // NSFoo
     | {constant}    constant                               // 0x1234
     | {string}      string                                 // @"str" @"concat"
     | {literal}     [type]:type [values]:initializer*      // c99 struct literal

     | {comma}       [left]:expr [right]:expr               // ((a,b))

     | {sizeof}      [value]:expr
     | {sizeof_type} [type]:type
     | {cast}        [value]:expr [type]:type

     | {selector}    [name]:ident*                          // @selector()
     | {protocol}    [name]:ident
     | {encode}      [type]:type
     ;

// Null declarator = abstract declarator
declarator
    = {init_declarator} [declarator]:declarator [initializer]:initializer
    | {pointer}   [to]:declarator? [type_qualifier]:type_qualifier*
    | {name}      [is]:ident
    | {array}     [of]:declarator? [size]:expr?
    | {array_vla} [of]:declarator? // variable length array[*]
    | {function}  [returning]:declarator?
    ;

initializer
    = {expression} [value]:expr
    | {aggregate} [initializers]:initializer*
    | {designated} [initializer]:initializer
    ;

message_argument = [name]:ident? [value]:expr?;

string = string_literal+;

type = ;

enumerator = [name]:ident [value]:expr?;

declaration_specifier
    = {storage_class} [storage_class]:storage_class_specifier
    | {type_qualifier} [type_qualifier]:type_qualifier
    | {type_specifier} [type_specifier]:type_specifier
    | {function_specifier} [function_specifier]:function_specifier
    ;

type_specifier
    = {base_type}  [type]:type_specifier_keywords
    | {typedefed}  [type]:typedefed_ident [protocols]:ident*
    | {type_ident} [type]:ident           [protocols]:ident*
    | {struct}     [name]:ident?
    | {union}      [name]:ident?
    | {enum}       [name]:ident? [enumerators]:enumerator*
    ;
